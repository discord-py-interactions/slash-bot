import asyncio
import importlib
import io

import aiohttp
import interactions as ipy

import common.utils as utils
from common.const import *


async def check_archive(ctx: ipy.BaseContext):
    return ctx.channel.parent_id in {METADATA["channels"]["help"], METADATA["channels"]["help-v4"]}


class HelpChannel(ipy.Extension):
    def __init__(self, bot: ipy.Client):
        self.client = bot
        self.session: aiohttp.ClientSession = bot.session
        self.help_channel: ipy.GuildForum = None  # type: ignore
        asyncio.create_task(self.fill_help_channel())

    async def fill_help_channel(self):
        await self.bot.wait_until_ready()
        self.help_channel = self.bot.get_channel(METADATA["channels"]["help"])  # type: ignore

    @ipy.context_menu("Create Help Thread", context_type=ipy.CommandType.MESSAGE)
    async def create_thread_context_menu(self, ctx: ipy.ContextMenuContext):
        message: ipy.Message = ctx.target  # type: ignore

        ctx.send

        thread_name = f"[AUTO] {message.content[:40]}"
        if len(message.content) > 40:
            thread_name += "..."

        modal = ipy.Modal(
            ipy.ShortText(
                label="What should the thread be named?",
                value=thread_name,
                min_length=1,
                max_length=100,
                custom_id="help_thread_name",
            ),
            ipy.ParagraphText(
                label="What should the question be?",
                value=message.content[:4000],
                min_length=1,
                max_length=4000,
                custom_id="edit_content",
            ),
            ipy.ParagraphText(
                label="Any addition information?",
                required=False,
                min_length=1,
                max_length=1024,
                custom_id="extra_content",
            ),
            title="Create Help Thread",
            custom_id=f"help_thread_creation_{message.channel.id}|{message.id}",
        )
        await ctx.send_modal(modal)
        await ctx.send(":white_check_mark: Modal sent.", ephemeral=True)

    def generate_tag_select(self, channel: ipy.GuildForum):
        tags = channel.available_tags
        options: list[ipy.StringSelectOption] = []

        for tag in tags:
            if tag.id == METADATA["autogenerated_tag"]:
                continue

            emoji = None
            if tag.emoji_id:
                emoji = ipy.PartialEmoji(id=tag.emoji_id, name=tag.emoji_name or "emoji")
            elif tag.emoji_name:
                emoji = ipy.PartialEmoji.from_str(tag.emoji_name)

            options.append(ipy.StringSelectOption(label=tag.name, value=str(tag.id), emoji=emoji))

        options.append(
            ipy.StringSelectOption(
                label="Remove all tags",
                value="remove_all_tags",
                emoji=ipy.PartialEmoji.from_str("ðŸ—‘"),
            ),
        )
        return ipy.StringSelectMenu(
            *options,
            placeholder="Select the tags you want",
            min_values=1,
            max_values=len(options),
            custom_id="tag_selection",
        )

    @ipy.listen("modal_completion")
    async def context_menu_handling(self, event: ipy.events.ModalCompletion):
        ctx = event.ctx

        if ctx.custom_id.startswith("help_thread_creation_"):
            await ctx.defer(ephemeral=True)

            channel_id, message_id = ctx.custom_id.removeprefix("help_thread_creation_").split("|")

            channel = self.bot.get_channel(int(channel_id))
            if not channel:
                return await utils.error_send(
                    ctx,
                    ":x: Could not find channel of message.",
                    ipy.MaterialColors.RED,
                )

            message = await channel.fetch_message(int(message_id))  # type: ignore
            if not message:
                return await utils.error_send(
                    ctx, ":x: Could not fetch message.", ipy.MaterialColors.RED
                )

            files: list[ipy.File] = []

            if message.attachments:
                for attahcment in message.attachments:
                    if attahcment.size > 8388608:  # if it's over 8 MiB, that's a bit much
                        continue

                    async with self.session.get(attahcment.proxy_url) as resp:
                        try:
                            resp.raise_for_status()
                        except aiohttp.ClientResponseError:
                            continue

                        raw_file = await resp.read()
                        files.append(ipy.File(io.BytesIO(raw_file), file_name=attahcment.filename))

            post_thread = await self.help_channel.create_post(
                ctx.responses["help_thread_name"],
                content=ctx.responses["edit_content"],
                applied_tags=[str(METADATA["autogenerated_tag"])],
                auto_archive_duration=1440,  # type: ignore
                files=files,  # type: ignore
                reason="Auto help thread creation",
            )

            await post_thread.add_member(ctx.author)
            await post_thread.add_member(message.author)

            embed = None

            if content := ctx.responses.get("extra_content"):
                embed = ipy.Embed(
                    title="Additional Information",
                    description=content,
                    color=ASTRO_COLOR,
                )
                embed.set_footer(text="Please create a thread in #help to ask questions!")

            select = self.generate_tag_select(self.help_channel)

            original_message_button = ipy.Button(
                style=ipy.ButtonStyle.LINK,
                label="Original message",
                url=message.jump_url,
            )
            close_button = ipy.Button(
                style=ipy.ButtonStyle.DANGER,
                label="Close this thread",
                custom_id="close_thread",
            )

            starter_message = await post_thread.send(
                (
                    "This help thread was automatically generated. Read the message"
                    " above for more information."
                ),
                embeds=embed,
                components=[[original_message_button], [select], [close_button]],
            )
            await starter_message.pin()

            await message.reply(
                f"Hey, {message.author.mention}! At this time, we only help with"
                " support-related questions in our help channel. Please redirect to"
                f" {post_thread.mention} in order to receive help."
            )
            await ctx.send(":white_check_mark: Thread created.", ephemeral=True)

    @ipy.listen("new_thread_create")
    async def first_message_for_help(self, event: ipy.events.NewThreadCreate):
        thread = event.thread
        if not thread.parent_id or int(thread.parent_id) not in {
            METADATA["channels"]["help"],
            METADATA["channels"]["help-v4"],
        }:
            return

        if thread.owner_id == self.bot.user.id:
            # an autogenerated thread, don't interfere
            return

        help_channel = thread.parent_channel
        select = self.generate_tag_select(help_channel)
        close_button = ipy.Button(
            style=ipy.ButtonStyle.DANGER,
            label="Close this thread",
            custom_id="close_thread",
        )

        try:
            message = await thread.send(
                "Hey! Once your issue is solved, press the button below to close this thread!",
                components=[[select], [close_button]],
            )
        except ipy.errors.HTTPException:
            # this tends to happen often if the "thread author has not sent their initial message"
            # techically, they already did because you can't make a thread otherwise...
            # so we're just waiting for discord to get the memo
            await asyncio.sleep(5)
            message = await thread.send(
                "Hey! Once your issue is solved, press the button below to close this thread!",
                components=[[select], [close_button]],
            )

        if int(thread.parent_id) == METADATA["channels"]["help-v4"]:
            deprecated_message = await thread.send(
                embed=ipy.Embed(
                    title="Warning",
                    description=(
                        "This version is deprecated, and while we will be helping you with this"
                        " issue, we may not help with this version in the future and heavily"
                        " recommend you upgrade to the latest major version."
                    ),
                    color=ipy.MaterialColors.YELLOW,
                )
            )
            await deprecated_message.pin()

        await message.pin()

    @ipy.component_callback("tag_selection")  # type: ignore
    async def modify_tags(self, ctx: ipy.ComponentContext):
        if not utils.proficient_check(ctx) and ctx.author.id != ctx.channel.owner_id:
            return await utils.error_send(
                ctx, ":x: You are not a proficient user.", ipy.MaterialColors.YELLOW
            )

        if ctx.channel.archived:
            return await ctx.defer(edit_origin=True)

        await ctx.defer(ephemeral=True)

        channel: ipy.GuildForumPost = ctx.channel  # type: ignore
        tags = [int(v) for v in ctx.values] if "remove_all_tags" not in ctx.values else []
        await channel.edit(applied_tags=tags)
        await ctx.send(":white_check_mark: Done.", ephemeral=True)

    @ipy.component_callback("TAG_SELECTION")  # type: ignore
    async def legacy_modify_tags(self, ctx: ipy.ComponentContext):
        await self.modify_tags.call_with_binding(self.modify_tags.callback, ctx)

    @ipy.check(check_archive)  # type: ignore
    @ipy.slash_command(
        "archive",
        description="Archives a help thread.",
        default_member_permissions=ipy.Permissions.MANAGE_CHANNELS,
    )
    async def archive(self, ctx: ipy.InteractionContext):
        await ctx.send(":white_check_mark: Archiving...")
        await ctx.channel.edit(archived=True, locked=True)

    @ipy.component_callback("close_thread")  # type: ignore
    async def close_help_thread(self, ctx: ipy.ComponentContext):
        if not utils.proficient_check(ctx) and ctx.author.id != ctx.channel.owner_id:
            return await utils.error_send(
                ctx, ":x: You are not a proficient user.", ipy.MaterialColors.YELLOW
            )

        if ctx.channel.archived:
            return await ctx.defer(edit_origin=True)

        await ctx.send(":white_check_mark: Closing. Thank you for using our help system.")
        await ctx.channel.edit(archived=True, locked=True)

    @ipy.component_callback("close thread")  # type: ignore
    async def legacy_close_thread(self, ctx: ipy.ComponentContext):
        await self.close_help_thread.call_with_binding(self.close_help_thread.callback, ctx)


def setup(bot):
    importlib.reload(utils)
    HelpChannel(bot)
